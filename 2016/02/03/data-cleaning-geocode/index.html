<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="R,Geocoding,Data Science,Data Cleaning," />





  <link rel="alternate" href="/atom.xml" title="From Learning and Evolution to Data Science" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="Summary This is my second post on topic of Data Cleaning.  Cleaning addresses format turned out to have a substantial positive impact on Geocoding performance. Deep understandings of address format st">
<meta name="keywords" content="R,Geocoding,Data Science,Data Cleaning">
<meta property="og:type" content="article">
<meta property="og:title" content="Data Cleaning Part 2 - Geocoding Addresses, Double The Performance By Cleaning">
<meta property="og:url" content="https://dracodoc.github.io/2016/02/03/data-cleaning-geocode/index.html">
<meta property="og:site_name" content="From Learning and Evolution to Data Science">
<meta property="og:description" content="Summary This is my second post on topic of Data Cleaning.  Cleaning addresses format turned out to have a substantial positive impact on Geocoding performance. Deep understandings of address format st">
<meta property="og:image" content="http://dracodoc.github.io/2015/11/19/Script-workflow/NFIRS_data_sample.png">
<meta property="og:updated_time" content="2016-08-19T13:55:46.098Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Data Cleaning Part 2 - Geocoding Addresses, Double The Performance By Cleaning">
<meta name="twitter:description" content="Summary This is my second post on topic of Data Cleaning.  Cleaning addresses format turned out to have a substantial positive impact on Geocoding performance. Deep understandings of address format st">
<meta name="twitter:image" content="http://dracodoc.github.io/2015/11/19/Script-workflow/NFIRS_data_sample.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="https://dracodoc.github.io/2016/02/03/data-cleaning-geocode/"/>

  <title> Data Cleaning Part 2 - Geocoding Addresses, Double The Performance By Cleaning | From Learning and Evolution to Data Science </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">From Learning and Evolution to Data Science</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Data Cleaning Part 2 - Geocoding Addresses, Double The Performance By Cleaning
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2016-02-03T16:17:59-05:00" content="2016-02-03">
              2016-02-03
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/R/" itemprop="url" rel="index">
                    <span itemprop="name">R</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2016/02/03/data-cleaning-geocode/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2016/02/03/data-cleaning-geocode/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ul>
<li>This is my second post on topic of Data Cleaning. </li>
<li>Cleaning addresses format turned out to have a substantial positive impact on Geocoding performance.</li>
<li>Deep understandings of address format standard is needed to deal with all kinds of special cases.</li>
</ul>
<a id="more"></a>
<h2 id="introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>I discussed a lot of interesting findings I discovered in NYC Taxi Trip data in <a href="dracodoc.github.io/2016/01/31/data-cleaning/">last post</a>. However it was not clear whether the cleaning added much value to the analysis other than some anomaly records were removed, and you can always check the outliers for any calculation and remove them when appropriate.</p>
<p>Actually there are some times that the data cleaning can have great benefits. I was <a href="http://dracodoc.github.io/2015/11/17/Geocoding/">geocoding lots of addresses from public data</a> recently, and found cleaning the addresses almost doubled the geocoding performance. This effect is not really mentioned anywhere as far as I know, and I only have a theory about how that is possible.</p>
<p>In short, I was feeding address strings to PostGIS Tiger Geocoder extension for geocoding.</p>
<p><img src="http://dracodoc.github.io/2015/11/19/Script-workflow/NFIRS_data_sample.png" alt="address format"></p>
<h2 id="clean-addresses-have-much-better-geocoding-performance"><a href="#Clean-Addresses-Have-Much-Better-Geocoding-Performance" class="headerlink" title="Clean Addresses Have Much Better Geocoding Performance"></a>Clean Addresses Have Much Better Geocoding Performance</h2><p>Simple assembling the columns could have lots of dirty inputs which will interfere with the Geocoder parsing. I first did one pass Geocoding on 2010 data, then checked the geocoding results. I filtered many type of dirty inputs that caused problems and cleaned them up. Using the cleaning routine on other years&#x2019; data, the geocoding performance doubled. </p>
<table>
<thead>
<tr>
<th style="text-align:left">NFIRS Data Year</th>
<th style="text-align:left">Addresses Count</th>
<th>Time Used</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">2009</td>
<td style="text-align:left">1,767,797</td>
<td>6.3 days</td>
</tr>
<tr>
<td style="text-align:left">2010</td>
<td style="text-align:left">1,829,731</td>
<td>14.28 days</td>
</tr>
<tr>
<td style="text-align:left">2011</td>
<td style="text-align:left">1,980,622</td>
<td>7.06 days</td>
</tr>
<tr>
<td style="text-align:left">2012</td>
<td style="text-align:left">1,843,434</td>
<td>6.57 days</td>
</tr>
<tr>
<td style="text-align:left">2013</td>
<td style="text-align:left">1,753,145</td>
<td>6.51 days</td>
</tr>
</tbody>
</table>
<p>I didn&#x2019;t find anybody mentioned this kind of performance gain in my thorough research on Geocoding performance tuning. Somebody suggested to normalize address first, but that didn&#x2019;t help on performance because the Geocoder actually will normalize address input anyway, unless your normalize procedure is vastly better than the built-in normalizer. My theory about this performance gain is as follows:</p>
<ol>
<li>Postgresql PostGIS server will try to cache all the data needed for geocoding in RAM. My Geocoding server can hold 1 ~ 2 states&#x2019; data in RAM, so I split the input addresses by states. Every input file are single state only. Ideally the server will not need to read from disk in most of time.</li>
<li>The problem is there are lots of addresses that have wrong zip code or city. The Geocoder can still process them but it will be much more slower because the Geocoder need to scan in a much broader range. It seemed that it will scan all states even if the state information is correct. I didn&#x2019;t find a way to limit the scan range to a known state, and this was confirmed by the Geocoder author.</li>
<li>The problematic addresses are scattered in the input file. Every time when the Geocoder meet them, it will scan all states and mess up the perfect cache, which caused lots of performance drop on the good addresses followed.</li>
<li>With the cleaning procedure in use, the bad address are either removed from input or collected into a special input file, separated from the good addresses. Now the Geocoder can process the good addresses much faster.</li>
</ol>
<h2 id="all-the-format-errors"><a href="#All-the-format-errors" class="headerlink" title="All the format errors"></a>All the format errors</h2><p>Here are the cleaning procedures I used. In the end I filtered and cleaned about 14% of data in many types.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><div class="line"><span class="comment"># loading data and preparing address string</span></div><div class="line">data_year = <span class="string">&apos;2010&apos;</span></div><div class="line"><span class="comment"># create year directory, load original address data, change year number here.</span></div><div class="line">load(paste0(<span class="string">&apos;data/address/&apos;</span>, data_year, <span class="string">&apos;_formated_addresses.Rdata&apos;</span>)) </div><div class="line">setnames(address,<span class="string">&apos;ZIP5&apos;</span>, <span class="string">&apos;zip&apos;</span>)</div><div class="line">address[, row_seq := as.numeric(row.names(address))]</div><div class="line">setkey(address, zip)</div><div class="line">address[, address_type := <span class="string">&apos;a&apos;</span>] <span class="comment"># type 1, 3,4,5 as addresses can be geocoded.</span></div><div class="line">address[LOC_TYPE == <span class="string">&apos;2&apos;</span>, address_type := <span class="string">&apos;i&apos;</span>]  <span class="comment"># to be combined with intersections in type 1 as intersections input</span></div><div class="line">address[LOC_TYPE %<span class="keyword">in</span>% c(<span class="string">&apos;6&apos;</span>, <span class="string">&apos;7&apos;</span>), address_type := <span class="string">&apos;n&apos;</span>] <span class="comment"># ignore 6,7</span></div><div class="line"><span class="comment"># original reference, change input string instead of original fields if possible</span></div><div class="line">address[, original_address :=</div><div class="line">                    paste0(NUM_MILE,<span class="string">&apos; &apos;</span>, STREET_PRE,<span class="string">&apos; &apos;</span>, STREETNAME,<span class="string">&apos; &apos;</span>, STREETTYPE, </div><div class="line">                           <span class="string">&apos; &apos;</span>, STREETSUF, <span class="string">&apos; &apos;</span>,APT_NO, <span class="string">&apos;, &apos;</span>, CITY, <span class="string">&apos;, &apos;</span>, STATE_ID, <span class="string">&apos; &apos;</span>, zip)]  </div></pre></td></tr></table></figure>
<p>There are many manually inputed symbols for NA:</p>
<pre><code>&gt; head(str_subset(address$original_address, &quot;N/A&quot;))
[1] &quot;55  Margaret ST  N/A, Monson, MA 01057&quot;         &quot;55  Margaret ST  N/A, Monson, MA 01057&quot;        
[3] &quot;1657  WORCESTER RD   N/A, FRAMINGHAM, MA 01701&quot; &quot;132  UNION AV   N/A, FRAMINGHAM, MA 01702&quot;     
[5] &quot;N/A  OAKLAND BEACH AV   , Warwick, RI 02889&quot;    &quot;00601  MERRITT 7 N/A  , NORWALK, CT 06850&quot;  

&gt; head(str_subset(address$original_address, &quot;null&quot;))
[1] &quot;96  Walworth ST  null, Saratoga Springs, NY 12866&quot; &quot;197 S Broadway   null, Saratoga Springs, NY 12866&quot;
[3] &quot;640  West Broadway   , Conconully, WA 98819&quot;       &quot;58  W Fork Rd   , Conconully, WA 98819&quot;           
[5] &quot;  Mineral Hill Rd   , Conconully, WA 98819&quot;        &quot;225  Conconully ST  , OKANOGAN, WA 98840&quot;   
</code></pre><p>Because &#x2018;NA&#x2019; or &#x2018;na&#x2019; could be a valid part in address string, it&#x2019;s better to clean them before concatenating fields into one address string. </p>
<pre><code>&gt; head(str_subset(address$original_address, &quot;NA&quot;))
[1] &quot;7821 W CINNABAR AV  , PEORIA, AZ 00000&quot;      &quot;7818 W PINNACLE PEAK RD  , PEORIA, AZ 00000&quot;
[3] &quot;8828 W SANNA ST  , PEORIA, AZ 00000&quot;         &quot;8221 W DEANNA DR  , PEORIA, AZ 00000&quot;       
[5] &quot;2026 W NANCY LN  , PHOENIX, AZ 00000&quot;        &quot;3548 E HELENA DR  , PHOENIX, AZ 00000&quot;  
</code></pre><p>Once I finished cleaning on fields, I will prepare a cleaner address string and do the further cleaning in that concatenated string. That&#x2019;s why I concatenated all original fields into <code>original_address</code>, which is for reference in case some fields changed in later process.</p>
<p>Most other cleaning process are better done in the whole string, because some input may go to wrong fields, like street number in street name instead of street number column. With the whole string this kind of error doesn&#x2019;t matter any more.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><div class="line"><span class="comment"># remove all kinds of input for NA</span></div><div class="line">str_subset(address$original_address, <span class="string">&quot;N/A&quot;</span>)</div><div class="line"><span class="keyword">for</span> (j <span class="keyword">in</span> seq_len(ncol(address)))</div><div class="line">    set(address,which(is.na(address[[j]]) | </div><div class="line">                        (address[[j]] %<span class="keyword">in</span>% c(<span class="string">&apos;N/A&apos;</span>,<span class="string">&apos;n/a&apos;</span>, <span class="string">&apos;NA&apos;</span>,<span class="string">&apos;na&apos;</span>, <span class="string">&apos;NULL&apos;</span>, <span class="string">&apos;null&apos;</span>))),j,<span class="string">&apos;&apos;</span>)  </div></pre></td></tr></table></figure>
<p>Many addresses&#x2019; zip code are wrong. </p>
<pre><code>&gt; sample(address[!grep(&apos;\\d\\d\\d\\d\\d&apos;, zip), zip], 20)
 [1] &quot;&quot;     &quot;06&quot;   &quot;&quot;     &quot;&quot;     &quot;625&quot;  &quot;021&quot;  &quot;33&quot;   &quot;021&quot;  &quot;461&quot;  &quot;&quot;     &quot;021&quot;  &quot;2008&quot; &quot;970&quot;  &quot;&quot;     &quot;11&quot;   &quot;021&quot;  &quot;021&quot; 
[18] &quot;9177&quot; &quot;&quot;     &quot;021&quot; 
</code></pre><p>The Geocoder can process address without zip code, but it have to be format like &#x2018;00000&#x2019;.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><div class="line"><span class="comment"># ---- some zip are invalid ----</span></div><div class="line">address[!grep(<span class="string">&apos;\\d\\d\\d\\d\\d&apos;</span>, zip), <span class="string">&apos;:=&apos;</span> (zip = <span class="string">&apos;00000&apos;</span>, address_type = <span class="string">&apos;az&apos;</span>)]     </div></pre></td></tr></table></figure>
<p>After the above 2 steps of direct modifying address fields, I prepared the address string and will process the whole string in all later cleaning.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><div class="line"><span class="comment"># ---- prepare address string (ignore apt_no) ---- </span></div><div class="line">address[, input_address :=</div><div class="line">                    paste0(NUM_MILE,<span class="string">&apos; &apos;</span>, STREET_PRE,<span class="string">&apos; &apos;</span>, STREETNAME,<span class="string">&apos; &apos;</span>, STREETTYPE, </div><div class="line">                           <span class="string">&apos; &apos;</span>, STREETSUF, <span class="string">&apos; &apos;</span>, <span class="string">&apos;, &apos;</span>, CITY, <span class="string">&apos;, &apos;</span>, STATE_ID, <span class="string">&apos; &apos;</span>, zip)]  </div><div class="line">address[, input_address := str_trim(gsub(<span class="string">&quot;\\s+&quot;</span>,<span class="string">&quot; &quot;</span>,input_address))]</div></pre></td></tr></table></figure>
<p>Some addresses are empty. </p>
<pre><code>&gt; head(address[STATE_ID == &apos;&apos; &amp; STREETNAME == &apos;&apos;, original_address])
[1] &quot;     , ,  &quot; &quot;     , ,  &quot; &quot;     , ,  &quot; &quot;     , ,  &quot; &quot;     , ,  &quot; &quot;     , ,  &quot;
</code></pre><figure class="highlight r"><table><tr><td class="code"><pre><div class="line"><span class="comment"># ---- ignore empty rows, most with empty state and zip ---- </span></div><div class="line"><span class="comment"># may came from duplicate records for same event from 2 dept</span></div><div class="line">address[STATE_ID == <span class="string">&apos;&apos;</span> &amp; STREETNAME == <span class="string">&apos;&apos;</span>, address_type := <span class="string">&apos;e&apos;</span>] </div></pre></td></tr></table></figure>
<p>There are lots of usage of speical symobls like <code>/</code>, <code>@</code>, <code>&amp;</code>, <code>*</code> in input which will interfere with the Geocoder.</p>
<pre><code>&gt; sample(address[LOC_TYPE == &apos;1&apos; &amp; str_detect(address$input_address, &quot;[/|@|&amp;]&quot;), input_address], 10)
 [1] &quot;743 CHENANGO ST , BINGHAMTON/FENTON, NY 13901&quot;             &quot;123/127 tennyson , highland park, MI 48203&quot;               
 [3] &quot;318 1/2 McMILLEN ST , Johnstown, PA 15902&quot;                 &quot;712 1/2 BURNSIDE DR , GARDEN CITY, KS 67846&quot;              
 [5] &quot;m/m143 W Interstate 16 , Ellabell, GA 31308&quot;               &quot;12538 Greensbrook Forest DR , Houston / Sheldon, TX 77044&quot;
 [7] &quot;F/O 1179 CASTLEHILL AVE , New York City, NY 10462&quot;         &quot;509 1/2 N Court , Ottumwa, IA 52501&quot;                      
 [9] &quot;7945 Larson , Hereford/Palominas, AZ 85615&quot;                &quot;1022 1/2 N Langdon ST , MITCHELL, SD 57301&quot;    
</code></pre><p>First I remove all the <code>1/2</code> since the Geocoder cannot recognize them, and removing them will not affect the Geocoding result accuracy.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><div class="line">address[str_detect(address$input_address, <span class="string">&quot;1/2&quot;</span>), </div><div class="line">        input_address := str_replace_all(input_address, <span class="string">&quot;1/2&quot;</span>, <span class="string">&quot;&quot;</span>)]</div></pre></td></tr></table></figure>
<p>Some used <code>*</code> to label intersections, which I will use different Geocoding scripts to process later.</p>
<pre><code>&gt; head(address[str_detect(input_address, &quot;[a-zA-Z]\\*[a-zA-Z]&quot;), input_address])
[1] &quot;16 MC*COOK PL , East Lyme, CT 06333&quot;             &quot;1236 WAL*MART PLZ , PHILLIPSBURG, NJ 08865&quot;     
[3] &quot;0 GREENSPRING AV*JFX , BROOKLANDVILLE, MD 21022&quot; &quot;0 BELFAST RD*SHAWAN RD , COCKEYSVILLE, MD 21030&quot;
[5] &quot;0 SHAWAN RD*WARREN RD , COCKEYSVILLE, MD 21030&quot;  &quot;0 SHAWAN RD*BELFAST RD , COCKEYSVILLE, MD 21030&quot;
</code></pre><figure class="highlight r"><table><tr><td class="code"><pre><div class="line">address[str_detect(input_address, <span class="string">&quot;[a-zA-Z]\\*[a-zA-Z]&quot;</span>), address_type := <span class="string">&apos;i_*&apos;</span>]</div></pre></td></tr></table></figure>
<p>Similarly filter other special symbols.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><div class="line">address[address_type == <span class="string">&apos;a&apos;</span> &amp; str_detect(address$input_address, <span class="string">&quot;[/|@|&amp;]&quot;</span>),</div><div class="line">        address_type := <span class="string">&apos;i_/@&amp;&apos;</span>]</div></pre></td></tr></table></figure>
<p>Many addresses used milepost numbers, which is a miles count along highway. They are not street addresses and cannot be processed by the Geocoder. There are all kinds of usage to record this type of address.</p>
<pre><code>&gt; head(str_subset(address$input_address, &quot;(?i)milepost&quot;))
[1] &quot;452.2E NYS Thruway Milepost , Angola, NY 14006&quot; &quot;447.4W NYS Thruway Milepost , Angola, NY 14006&quot;
[3] &quot;446W NYS Thruway Milepost , Angola, NY 14006&quot;   &quot;447.4 NYS Thruway Milepost , Angola, NY 14006&quot; 
[5] &quot;444.1W NYS Thruway Milepost , Angola, NY 14006&quot; &quot;I-94 MILEPOST 68 , Eau Claire, WI 54701&quot;       

&gt; head(str_subset(address$input_address, &quot;\\bmile\\b|\\bmiles\\b&quot;))
[1] &quot;2.5 mile Schillinger RD , T8R3 NBPP, ME 00000&quot;        &quot;cr 103(2 miles west of 717) , breckenridge, TX 00000&quot;
[3] &quot;Interstate 93 south mile mark , WINDHAM, NH 03087&quot;    &quot;183 lost mile rd. , parsonfield, ME 04047&quot;           
[5] &quot;168 lost mile RD , w.newfield, ME 04095&quot;              &quot;20 mile stream rd , proctorsville, VT 05153&quot;   
</code></pre><p>Note it&#x2019;s still possible to have some valid street address with <code>mile</code> as a word in address(my regular expression only check when <code>mile</code> is a whole word, not part of word), but it should be very rare and difficult to separate the valid addresses from the milepost usage. So I&#x2019;ll just ignore all of them.</p>
<figure class="highlight r"><table><tr><td class="code"><pre><div class="line">address[str_detect(paste0(NUM_MILE, STREETNAME), <span class="string">&quot;\\bmile\\b|\\bmiles\\b&quot;</span>), address_type := <span class="string">&apos;m&apos;</span>]</div><div class="line">address[str_detect(address$input_address, <span class="string">&quot;(?i)milepost&quot;</span>), address_type := <span class="string">&apos;m&apos;</span>]</div></pre></td></tr></table></figure>
<p>Another special format of address is grid style address. I decided to remove the grid number part and keep the rest of address. The Geocoder will get a rough location for that street or city, which is still helpful for my purpose. The Geocoding match score will separate this kind of rough match from the exact match of street addresses.</p>
<blockquote>
<p>Grid-style Complete Address Numbers (Example: &#x201C;N89W16758&#x201D;). In certain communities in and around southern Wisconsin, Complete Address Numbers include a map grid cell reference preceding the Address Number. In the examples above, &#x201C;N89W16758&#x201D; should be read as &#x201C;North 89, West 167, Address Number 58&#x201D;. &#x201C;W63N645&#x201D; should be read as &#x201C;West 63, North, Address Number 645.&#x201D; The north and west values specify a locally-defined map grid cell with which the address is located. Local knowledge is needed to know when the grid reference stops and the Address Number begins.<br>Page 37, <a href="https://www.fgdc.gov/standards/projects/FGDC-standards-projects/street-address/index_html" target="_blank" rel="external">United States Thoroughfare, Landmark, and Postal Address Data Standard</a></p>
</blockquote>
<p>Most are WI and MN addresses. Except the <code>E003</code> NY address, I&#x2019;m not sure what does that means. Since the Geocoder cannot handle it either, they can be removed.</p>
<pre><code>&gt; sample(address[str_detect(address$input_address, &quot;^[NSWEnswe]\\d&quot;), input_address], 10)
 [1] &quot;W26820 Shelly Lynn DR , Pewaukee, WI 53072&quot;      &quot;E14 GATE , St. Paul, MN 55111&quot;                  
 [3] &quot;W5336 Fairview ROAD , Monticello, WI 53570&quot;      &quot;W22870 Marjean LA , Pewaukee, WI 53072&quot;         
 [5] &quot;E003 , New York City, NY 10011&quot;                  &quot;W15085 Appleton AVE , Menomonee Falls, WI 53051&quot;
 [7] &quot;N7324 Lake Knutson RD , Iola, WI 54945&quot;          &quot;N10729 Hwy 17 S. , Rhinelander, WI 54501&quot;       
 [9] &quot;N2494 St. Hwy. 162 , La Crosse, WI 54601&quot;        &quot;N2639 Cty Hwy Z , Palmyra, WI 53156&quot;   
</code></pre><figure class="highlight r"><table><tr><td class="code"><pre><div class="line">address[str_detect(address$input_address, <span class="string">&quot;^[NSWEnswe]\\d&quot;</span>) &amp; address_type == <span class="string">&apos;a&apos;</span>, </div><div class="line">        address_type := <span class="string">&apos;ag&apos;</span>]</div><div class="line">address[address_type == <span class="string">&apos;ag&apos;</span>, </div><div class="line">        input_address := str_replace(input_address, <span class="string">&quot;^[NSWEnswe]\\d\\w*\\s&quot;</span>, <span class="string">&quot;&quot;</span>)]</div></pre></td></tr></table></figure>
<p>Some addresses have double quotes in it. Paired double quotes can be handled by the csv and Geocoder, but single double quote will cause problem for csv file.</p>
<pre><code>&gt; sample(address[str_detect(input_address, &apos;&quot;&apos;), input_address], 10)
 [1] &quot;317 IND \&quot;C\&quot; line at 14th ST , New York City, NY 10011&quot; &quot;750 W \&quot;D\&quot; AVE , Kingman, KS 67068&quot;                    
 [3] &quot;HWY \&quot;32\&quot; , SHEBOYGAN, WI 53083&quot;                        &quot;22796 \&quot;H\&quot; DR N , Marshall, MI 49068&quot;                  
 [5] &quot;5745 CR 631 \&quot;C\&quot; ST , Bushnell, FL 33513&quot;               &quot;CTY \&quot;MM\&quot; , HOWARDS GROVE, WI 53083&quot;                   
 [7] &quot;\&quot;BB\&quot; HWY , West Plains, MO 65775&quot;                      &quot;I-55 (MAIN TO HWY \&quot;M\&quot;) , Imperial, MO 63052&quot;          
 [9] &quot;3400 Wy\&quot;East RD , Hood River, OR 97031&quot;                 &quot;6555 Hwy \&quot;D\&quot; , parma, MO 63870&quot;    
</code></pre><figure class="highlight r"><table><tr><td class="code"><pre><div class="line"><span class="comment"># remove single double quote</span></div><div class="line">address[str_detect(input_address, <span class="string">&apos;(?m)(^[^&quot;]*)&quot;([^&quot;]*$)&apos;</span>) &amp; </div><div class="line">          str_detect(address_type, <span class="string">&quot;^a&quot;</span>), address_type := <span class="string">&apos;aq&apos;</span>]</div><div class="line">address[address_type == <span class="string">&apos;aq&apos;</span>, </div><div class="line">        input_address := str_replace_all(input_address, <span class="string">&apos;(?m)(^[^&quot;]*)&quot;([^&quot;]*$)&apos;</span>, <span class="string">&quot;\\1\\2&quot;</span>)]</div></pre></td></tr></table></figure>
<p>Some addresses used (), which cause problems for the Geocoder. The stuff inside () can be removed.</p>
<pre><code>&gt; sample(address[str_detect(address$input_address, &quot;\\(.*\\)&quot;), input_address], 10)
 [1] &quot;hwy 56 (side of beersheba mt) , beersheba springs, TN 37305&quot;
 [2] &quot;805 PARKWAY (DOWNTOWN) RD , Gatlinburg, TN 37738&quot;           
 [3] &quot;3409 JAMESWAY DR SW , Bernalillo (County), NM 87105&quot;        
 [4] &quot;96 Arroyo Hondo Road , Santa Fe (County), NM 87508&quot;         
 [5] &quot;3555 Dobbins Bridge RD , Anderson (County), SC 29625&quot;       
 [6] &quot;KARPER (12100-14999) RD , MERCERSBURG, PA 17236&quot;            
 [7] &quot;15.5 I-81 (10001-16000) LN N , Chambersburg, PA 17201&quot;      
 [8] &quot;30 Wintergreen DR , Beaufort (County), SC 29906&quot;            
 [9] &quot;305 Rosecrest RD , Spartanburg (County), SC 29303&quot;          
[10] &quot;1678 ROUTE 12 (Gales Ferry) , Gales Ferry, CT 06335&quot;   
</code></pre><figure class="highlight r"><table><tr><td class="code"><pre><div class="line"><span class="comment"># remove paired ()</span></div><div class="line">address[str_detect(address$input_address, <span class="string">&quot;\\(.*\\)&quot;</span>), address_type := <span class="string">&apos;a()&apos;</span>]</div><div class="line">address[address_type == <span class="string">&apos;a()&apos;</span>, </div><div class="line">        input_address := str_replace_all(input_address, <span class="string">&quot;\\(.*\\)&quot;</span>, <span class="string">&quot;&quot;</span>)]</div></pre></td></tr></table></figure>
<p>After this step, there are still some single ( cases.</p>
<pre><code>&gt; sample(address[str_detect(input_address, &quot;\\(&quot;), input_address], 10)
 [1] &quot;65 E Interstate 26 HWY , Columbus (Township o, NC 28722&quot;   
 [2] &quot;4496 SYCAMORE GROVE (4300-4799 RD , Chambersburg, PA 17201&quot;
 [3] &quot;AAA RD , Fort Hood (U.S. Army, TX 76544&quot;                   
 [4] &quot;2010 Catherine Lake RD , Richlands (Township, NC 28574&quot;    
 [5] &quot;285 Scott CIR NW , Calhoun (St. Address, GA 30701&quot;         
 [6] &quot;Highway 411 NE , Calhoun (St. Address, GA 30701&quot;           
 [7] &quot;2626 HILLTOP CT SW , Littlerock (RR name, WA 98556&quot;        
 [8] &quot;144 Tyler Ct. , Richland (Township o, PA 15904&quot;            
 [9] &quot;263 Farmington AVE , Farmington (Health C, CT 06030&quot;       
[10] &quot;12957 Roberts RD , Hartford (Township o, OH 43013&quot;     
</code></pre><figure class="highlight r"><table><tr><td class="code"><pre><div class="line">address[str_detect(input_address, <span class="string">&quot;\\(&quot;</span>), address_type := <span class="string">&apos;a(&apos;</span>]</div><div class="line"><span class="comment"># other than the case that ( in beginning, all content from ( to , to be removed.</span></div><div class="line">address[str_detect(input_address, <span class="string">&quot;^\\(&quot;</span>), </div><div class="line">                        input_address := str_replace(input_address, <span class="string">&quot;^\\(&quot;</span>, <span class="string">&quot;&quot;</span>)]</div><div class="line">address[str_detect(input_address, <span class="string">&quot;\\(&quot;</span>), </div><div class="line">                        input_address := str_replace(input_address, <span class="string">&quot;\\(.*(,)&quot;</span>, <span class="string">&quot;\\1&quot;</span>)]</div></pre></td></tr></table></figure>
<p>Some used ; to add additional information, which will only cause trouble for the Geocoder.</p>
<pre><code>&gt; sample(address[str_detect(input_address, &quot;;&quot;), input_address], 10)
 [1] &quot;1816 MT WASHINGTON AV #1; WHIT , Colorado Springs, CO 80906&quot;
 [2] &quot;3201 E PLATTE AV; WAL-MART STO , Colorado Springs, CO 00000&quot;
 [3] &quot;1511 YUMA ST #2; CONOVER APART , Colorado Springs, CO 80909&quot;
 [4] &quot;3550 AFTERNOON CR; MSGT ROY P , Colorado Springs, CO 80910&quot; 
 [5] &quot;805 S CIRCLE DR #B2; APOLLO PA , Colorado Springs, CO 00000&quot;
 [6] &quot;5590 POWERS CENTER PT; SEVEN E , Colorado Springs, CO 80920&quot;
 [7] &quot;715 CHEYENNE MEADOWS RD; DIAMO , Colorado Springs, CO 80906&quot;
 [8] &quot;3140 VAN TEYLINGEN DR #A; SIER , Colorado Springs, CO 00000&quot;
 [9] &quot;Meadow Rd; rifle clu , Hampden, OO 04444&quot;                   
[10] &quot;3301 E SKELLY DR;J , TULSA, OK 74105&quot;       
</code></pre><figure class="highlight r"><table><tr><td class="code"><pre><div class="line">address[str_detect(input_address, <span class="string">&quot;;&quot;</span>), address_type := <span class="string">&apos;a;&apos;</span>]</div><div class="line">address[address_type == <span class="string">&apos;a;&apos;</span>, </div><div class="line">        input_address := str_replace(input_address, <span class="string">&quot;;.*?(,)&quot;</span>, <span class="string">&quot;\\1&quot;</span>)]</div></pre></td></tr></table></figure>
<p>Some have *.</p>
<pre><code>&gt; sample(address[str_detect(address$input_address, &quot;\\*&quot;) &amp; address_type == &apos;a&apos;, input_address], 10)
 [1] &quot;TAYLOR ST , *Holyoke, MA 01040&quot;            &quot;NORTHAMPTON ST , *Holyoke, MA 01040&quot;      
 [3] &quot;1*5* W Coral RD , Stanton, MI 48888&quot;       &quot;Cr 727 *26 , angleton, TX 77515&quot;          
 [5] &quot;378 APPLETON ST , *Holyoke, MA 01040&quot;      &quot;0 I195*I895 , ARBUTUS, MD 21227&quot;          
 [7] &quot;1504 NORTHAMPTON ST , *Holyoke, MA 01040&quot;  &quot;50 RIVER TER , *Holyoke, MA 01040&quot;        
 [9] &quot;BOOKER ST * CARVER ST , Palatka, FL 32177&quot; &quot;19 OCONNOR AVE , *HOLYOKE, MA 01040&quot;   
</code></pre><figure class="highlight r"><table><tr><td class="code"><pre><div class="line">address[str_detect(address$input_address, <span class="string">&quot;\\*&quot;</span>) &amp; address_type == <span class="string">&apos;a&apos;</span>, address_type := <span class="string">&apos;a*&apos;</span>]</div><div class="line">address[address_type == <span class="string">&apos;a*&apos;</span>, input_address := str_replace_all(input_address, <span class="string">&quot;\\*&quot;</span>, <span class="string">&quot;&quot;</span>)]</div></pre></td></tr></table></figure>
<p>This looks like came from some program output.</p>
<pre><code>&gt; head(address[str_detect(address_type, &quot;^a&quot;) &amp; str_detect(input_address, &quot;\\*&quot;), input_address])
[1] &quot;5280 Bruns RD , **UNDEFINED, CA 00000&quot;         &quot;6500 Lindeman RD , **UNDEFINED, CA 00000&quot;     
[3] &quot;5280 Bruns RD , **UNDEFINED, CA 00000&quot;         &quot;17501 Sr 4 , **UNDEFINED, CA 00000&quot;           
[5] &quot;5993 Bethel Island RD , **UNDEFINED, CA 00000&quot; &quot;1 Quail Hill LN , **UNDEFINED, CA 00000&quot;   
</code></pre><figure class="highlight r"><table><tr><td class="code"><pre><div class="line">address[str_detect(address_type, <span class="string">&quot;^a&quot;</span>) &amp; str_detect(input_address, <span class="string">&quot;\\*&quot;</span>),</div><div class="line">        input_address := str_replace(input_address, <span class="string">&quot;\\*\\*UNDEFINED&quot;</span>, <span class="string">&quot;&quot;</span>)]</div></pre></td></tr></table></figure>
<p>Almost any special character that OK for human reading still cannot be handled by the Geocoder.</p>
<pre><code>&gt; sample(address[str_detect(input_address, &quot;^#&quot;), input_address], 10)
 [1] &quot;# 6 HIGH , Marks, MS 38646&quot;                          &quot;#560 CR56 , MAPLECREST, NY 12454&quot;                   
 [3] &quot;#250blk Durgintown rd. , Hiram, ME 04041&quot;            &quot;#888 Durgintown Rd. , Hiram, ME 04041&quot;              
 [5] &quot;#15 LITTLE KANAWHA RIVER RD , PARKERSBURG, WV 26101&quot; &quot;# 12 HOLLOW RD , WELLSTON, OH 45692&quot;                
 [7] &quot;#10 I-24 , Paducah, KY 42003&quot;                        &quot;#10.5 mm St RD 264 , Yahtahey, NM 87375&quot;            
 [9] &quot;#1 CANAL RD , SENECA, IL 61360&quot;                      &quot;#08 N Ola DR , Yahtahey, NM 87375&quot; 
</code></pre><figure class="highlight r"><table><tr><td class="code"><pre><div class="line">address[str_detect(input_address, <span class="string">&quot;^#&quot;</span>), address_type := <span class="string">&apos;a#&apos;</span>]</div><div class="line">address[address_type == <span class="string">&apos;a#&apos;</span>, input_address := str_replace_all(input_address, <span class="string">&quot;^#&quot;</span>, <span class="string">&quot;&quot;</span>)]</div></pre></td></tr></table></figure>
<p>All these steps may look cumbersome. Actually I just check the Geocoding results on one year data raw input, find all the problems and errors, clean them by types. Then I apply same cleaning code to other years because they are very similar, and I got the Geocoding performance doubled! I think this cleaning is well worth the effort.</p>
<h2 id="version-history"><a href="#Version-History" class="headerlink" title="Version History"></a>Version History</h2><ul>
<li>2016-02-03 : First version.</li>
<li>2016-05-11 : Added Summary.</li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/R/" rel="tag">#R</a>
          
            <a href="/tags/Geocoding/" rel="tag">#Geocoding</a>
          
            <a href="/tags/Data-Science/" rel="tag">#Data Science</a>
          
            <a href="/tags/Data-Cleaning/" rel="tag">#Data Cleaning</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/01/31/data-cleaning/" rel="next" title="Data Cleaning Part 1 - NYC Taxi Trip Data, Looking For Stories Behind Errors">
                <i class="fa fa-chevron-left"></i> Data Cleaning Part 1 - NYC Taxi Trip Data, Looking For Stories Behind Errors
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/08/10/rstudio-addin/" rel="prev" title="RStudio addin - extend RStudio in your way">
                RStudio addin - extend RStudio in your way <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="dracodoc" />
          <p class="site-author-name" itemprop="name">dracodoc</p>
          <p class="site-description motion-element" itemprop="description">This is about my exploration of Data Science, came from research background of AI, artificial learning and evolution.</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">10</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">21</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.R-bloggers.com" title="R-bloggers" target="_blank">R-bloggers</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#summary"><span class="nav-number">1.</span> <span class="nav-text">Summary</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#introduction"><span class="nav-number">2.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#clean-addresses-have-much-better-geocoding-performance"><span class="nav-number">3.</span> <span class="nav-text">Clean Addresses Have Much Better Geocoding Performance</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#all-the-format-errors"><span class="nav-number">4.</span> <span class="nav-text">All the format errors</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#version-history"><span class="nav-number">5.</span> <span class="nav-text">Version History</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dracodoc</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'dracodocgithub';
      var disqus_identifier = '2016/02/03/data-cleaning-geocode/';
      var disqus_title = "Data Cleaning Part 2 - Geocoding Addresses, Double The Performance By Cleaning";
      var disqus_url = 'https://dracodoc.github.io/2016/02/03/data-cleaning-geocode/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  




  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });

                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

</body>
</html>
