<!doctype html>



  


<html class="theme-next mist use-motion">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>



<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />












  
  
  <link href="/vendors/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/vendors/font-awesome/css/font-awesome.min.css?v=4.4.0" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.0.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="DataKind,NFIRS,Geocoding,Tiger Geocoder,PostGIS,postgresql," />





  <link rel="alternate" href="/atom.xml" title="From Learning and Evolution to Data Science" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.0.1" />






<meta name="description" content="Summary
I discussed all the problem I met, approaches I tried, and improvement I achieved in the Geocoding task.
There are many subtle details, some open questions and areas can be improved.
The final">
<meta property="og:type" content="article">
<meta property="og:title" content="Script And Workflow For Batch Geocoding Millions Of Address With PostGIS Tiger Geocoder">
<meta property="og:url" content="http://dracodoc.github.io/2015/11/19/Script-workflow/index.html">
<meta property="og:site_name" content="From Learning and Evolution to Data Science">
<meta property="og:description" content="Summary
I discussed all the problem I met, approaches I tried, and improvement I achieved in the Geocoding task.
There are many subtle details, some open questions and areas can be improved.
The final">
<meta property="og:image" content="http://dracodoc.github.io/NFIRS_data_sample.png">
<meta property="og:image" content="http://dracodoc.github.io/table1.png">
<meta property="og:image" content="http://dracodoc.github.io/table2.png">
<meta property="og:image" content="http://dracodoc.github.io/table3.png">
<meta property="og:image" content="http://dracodoc.github.io/table4.png">
<meta property="og:image" content="http://dracodoc.github.io/table5.png">
<meta property="og:image" content="http://dracodoc.github.io/1_explain_scan_v1.png">
<meta property="og:image" content="http://dracodoc.github.io/2_explain_limit_v1.png">
<meta property="og:image" content="http://dracodoc.github.io/3_explain_scan_v2.png">
<meta property="og:image" content="http://dracodoc.github.io/4_explain_scan_v1_2nd_run.png">
<meta property="og:updated_time" content="2016-08-19T19:39:10.803Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Script And Workflow For Batch Geocoding Millions Of Address With PostGIS Tiger Geocoder">
<meta name="twitter:description" content="Summary
I discussed all the problem I met, approaches I tried, and improvement I achieved in the Geocoding task.
There are many subtle details, some open questions and areas can be improved.
The final">
<meta name="twitter:image" content="http://dracodoc.github.io/NFIRS_data_sample.png">



<script type="text/javascript" id="hexo.configuration">
  var NexT = window.NexT || {};
  var CONFIG = {
    scheme: 'Mist',
    sidebar: {"position":"left","display":"post"},
    fancybox: true,
    motion: true,
    duoshuo: {
      userId: 0,
      author: 'Author'
    }
  };
</script>




  <link rel="canonical" href="http://dracodoc.github.io/2015/11/19/Script-workflow/"/>

  <title> Script And Workflow For Batch Geocoding Millions Of Address With PostGIS Tiger Geocoder | From Learning and Evolution to Data Science </title>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  










  
  
    
  

  <div class="container one-collumn sidebar-position-left page-post-detail ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-meta ">
  

  <div class="custom-logo-site-title">
    <a href="/"  class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <span class="site-title">From Learning and Evolution to Data Science</span>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>
  <p class="site-subtitle"></p>
</div>

<div class="site-nav-toggle">
  <button>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
    <span class="btn-bar"></span>
  </button>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup">
 <span class="search-icon fa fa-search"></span>
 <input type="text" id="local-search-input">
 <div id="local-search-result"></div>
 <span class="popup-btn-close">close</span>
</div>


    </div>
  
</nav>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  
  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
            
            
              
                Script And Workflow For Batch Geocoding Millions Of Address With PostGIS Tiger Geocoder
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">
            <span class="post-meta-item-icon">
              <i class="fa fa-calendar-o"></i>
            </span>
            <span class="post-meta-item-text">Posted on</span>
            <time itemprop="dateCreated" datetime="2015-11-19T15:05:00-05:00" content="2015-11-19">
              2015-11-19
            </time>
          </span>

          
            <span class="post-category" >
              &nbsp; | &nbsp;
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">In</span>
              
                <span itemprop="about" itemscope itemtype="https://schema.org/Thing">
                  <a href="/categories/Geocoding/" itemprop="url" rel="index">
                    <span itemprop="name">Geocoding</span>
                  </a>
                </span>

                
                

              
            </span>
          

          
            
              <span class="post-comments-count">
                &nbsp; | &nbsp;
                <a href="/2015/11/19/Script-workflow/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count disqus-comment-count" data-disqus-identifier="2015/11/19/Script-workflow/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          

          
          

          
        </div>
      </header>
    


    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="summary"><a href="#Summary" class="headerlink" title="Summary"></a>Summary</h2><ul>
<li>I discussed all the problem I met, approaches I tried, and improvement I achieved in the Geocoding task.</li>
<li>There are many subtle details, some open questions and areas can be improved.</li>
<li>The final working script and complete workflow are hosted in <a href="https://github.com/dracodoc/Geocode" target="_blank" rel="external">github</a>.</li>
</ul>
<a id="more"></a>
<h2 id="introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h2><p>This is the detailed discussion of my script and workflow for geocoding NFIRS data. See <a href="http://dracodoc.github.io/2015/11/11/Red-Cross-Smoke-Alarm-Project/">background of project</a> and <a href="http://dracodoc.github.io/2015/11/17/Geocoding/">the system setup</a> in my previous posts.</p>
<p>So I have 18 million addresses like this, how can I geocode them into valid address, coordinates and map to census block?<br><img src="NFIRS_data_sample.png" alt="NFIRS data sample"></p>
<h2 id="tiger-geocoder-geocode-function"><a href="#Tiger-Geocoder-Geocode-Function" class="headerlink" title="Tiger Geocoder Geocode Function"></a>Tiger Geocoder Geocode Function</h2><p>Tiger Geocoder extension have this <a href="http://postgis.net/docs/Geocode.html" target="_blank" rel="external"><code>geocode</code> function</a> to take in address string then output a set of possible locations and coordinates. A perfect formated accurate address could have an exact match in 61ms, but if there are misspelling or other non-perfect input, it could take much longer time.</p>
<p>Since geocoding performance varies a lot depending on the case and I have 18 millions address to geocode, I need to take every possible measure to improve the performance and finish the task with less hours. I searched numerous discussions about improving performance and tried most of them.</p>
<h2 id="preparing-addresses"><a href="#Preparing-Addresses" class="headerlink" title="Preparing Addresses"></a>Preparing Addresses</h2><p>First I need to prepare my address input. Technically NFIRS data have a column of <code>Location Type</code> to separate street addresses, intersections and other type of input. I filtered the addresses with the street address type then further removed many rows that obviously are still intersections.</p>
<p>NFIRS designed many columns for different part of an address, like street prefix, suffix, apt number etc. I concatenate them into a string formated to meet the <code>geocode</code> function expectation. <strong>A good format with proper comma separation could make the geocode function&#x2019;s work much easier</strong>. One bonus of concatenating the address segments is that some misplaced input columns will be corrected, for example some rows have the street number in street name column.</p>
<p>There are still numerous input errors, but I didn&#x2019;t plan to clean up too much first. Because I don&#x2019;t know what will cause problems before actually running the geocoding process . It will be probably easier to run one pass for one year&#x2019;s data first, then collect all the formatting errors, clean them up and feed them for second pass. After this round I can use the clean up procedures to process other years&#x2019; data before geocoding.</p>
<p>Another tip I found about improving geocoding performance is to <strong>process one state at a time, maybe sort the address by zipcode</strong>. Because I want the postgresql server to cache everything needed for geocoding in RAM and avoid disk access as much as possible. With limited RAM it&#x2019;s better to only process similar address at a time. Split huge data file into smaller tasks also make it easier to find problem or deal with exceptions, of course you will need a good batch processing workflow to process more input files.</p>
<p>Someone also mentioned that to <strong>standardize the address first, remove the invalid addresses</strong> since they take the most time to geocode. However I&#x2019;m not sure how can I verify the valid address without actual geocoding. Some addresses are obviously missing street numbers and cannot have an exact location, but I may still need the ballpark location for my analysis. They may not be able to be mapped to census block, but a census tract mapping could still be helpful. After the first pass on one year&#x2019;s data I will design a much more complete cleaning process, which could make the geocoding function&#x2019;s job a little bit easier.</p>
<p><a href="http://postgis.net/docs/postgis_installation.html#tiger_pagc_address_standardizing" target="_blank" rel="external">The PostGIS documentation</a> did mention that the built-in address normalizer is not optimal and they have a better pagc address standardizer can be used. I tried to enable it in the linux setup but failed. It seemed that I need to reinstall postgresql since it is not included in the postgresql setup process of the ansible playbook. The newer version PostGIS 2.2.0 released in Oct, 2015 seemed to have <em>&#x201C;New high-speed native code address standardizer&#x201D;</em>, while the ansible playbook used <code>PostgreSQL 9.3.10</code> and <code>PostGIS 2.1.2 r12389</code>.  This is a direction I&#x2019;ll explore later.</p>
<h2 id="test-geocoding-function"><a href="#Test-Geocoding-Function" class="headerlink" title="Test Geocoding Function"></a>Test Geocoding Function</h2><p>Based on the example given in <code>geocode</code> function documentation, I wrote my version of SQL command to geocode address like this:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> g.rating,</span><br><span class="line">        pprint_addy(g.addy),</span><br><span class="line">        ST_X(g.geomout)::<span class="built_in">numeric</span>(<span class="number">8</span>,<span class="number">5</span>) <span class="keyword">AS</span> lon,</span><br><span class="line">        ST_Y(g.geomout)::<span class="built_in">numeric</span>(<span class="number">8</span>,<span class="number">5</span>) <span class="keyword">AS</span> lat,</span><br><span class="line">        g.geomout</span><br><span class="line"><span class="keyword">FROM</span> geocode(<span class="string">&apos;2198 Florida Ave NW, Washington, DC 20008&apos;</span>, <span class="number">1</span>) <span class="keyword">AS</span> g;</span><br></pre></td></tr></table></figure>
<ul>
<li>the <code>1</code> parameter in geocode function limit the output to single address with best rating, since we don&#x2019;t have any other method to compare all the output.</li>
<li>rating is needed because I need to know the match score for result. 0 is for perfect match, and 100 is for very rough match which I probably will not use.</li>
<li><code>pprint_addy</code> give a pretty print of address in format that people familiar.</li>
<li><code>geomout</code> is the point geometry of the match. I want to save this because it is a more precise representation and I may need it for census block mapping.</li>
<li><code>lon</code> and <code>lat</code> are the coordinates round up to 5 digits after dot. The 6th digit will be in range of 1 m. Since most street address locations are interpolated and can be off a lot, there is no point to keep more digits.</li>
</ul>
<p>The next step is to make it work for many rows instead of just single input. I formated the addresses in R and wrote to csv file with this format:</p>
<table>
<thead>
<tr>
<th style="text-align:left">row_seq</th>
<th style="text-align:left">input_address</th>
<th style="text-align:center">zip</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">42203</td>
<td style="text-align:left">7365 RACE RD , HARMENS, MD 00000</td>
<td style="text-align:center">00000</td>
</tr>
<tr>
<td style="text-align:left">53948</td>
<td style="text-align:left">37 Parking Ramp , Washington, DC 20001</td>
<td style="text-align:center">20001</td>
</tr>
<tr>
<td style="text-align:left">229</td>
<td style="text-align:left">1315 5TH ST NW , WASHINGTON, DC 20001</td>
<td style="text-align:center">20001</td>
</tr>
<tr>
<td style="text-align:left">688</td>
<td style="text-align:left">1014 11TH ST NE , WASHINGTON, DC 20001</td>
<td style="text-align:center">20001</td>
</tr>
<tr>
<td style="text-align:left">2599</td>
<td style="text-align:left">100 RANDOLPH PL NW , WASHINGTON, DC 20001</td>
<td style="text-align:center">20001</td>
</tr>
</tbody>
</table>
<p>The <code>row_seq</code> is the unique id I assigned to every row so I can link the output back to the original table. <code>zip</code> is needed because I want to sort the addresses by zipcode. Another bonus is that addresses with obvious wrong zipcode will be shown together in beginning or ending of the file. I used the pipe symbol <code>|</code> as the separator of csv because there could be quotes and commas in columns.</p>
<p>Then I can read the csv into a table in postgresql database. The <code>geocode</code> function documentation provided an example to geocode addresses in batch mode, and most discussions in web seemed to be based on this example.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- only update the first 3 addresses (323-704 ms</span></span><br><span class="line"><span class="comment">-- there are caching and shared memory effects so first geocode you do is always slower)</span></span><br><span class="line"><span class="comment">-- for large numbers of addresses you don&apos;t want to update all at once</span></span><br><span class="line"><span class="comment">-- since the whole geocode must commit at once</span></span><br><span class="line"><span class="comment">-- For this example we rejoin with LEFT JOIN</span></span><br><span class="line"><span class="comment">-- and set to rating to -1 rating if no match</span></span><br><span class="line"><span class="comment">-- to ensure we don&apos;t regeocode a bad address</span></span><br><span class="line"><span class="keyword">UPDATE</span> addresses_to_geocode</span><br><span class="line">  <span class="keyword">SET</span> ( rating, new_address, lon, lat)</span><br><span class="line">    = ( <span class="keyword">COALESCE</span>((g.geo).rating,<span class="number">-1</span>), pprint_addy((g.geo).addy),</span><br><span class="line">       ST_X((g.geo).geomout)::<span class="built_in">numeric</span>(<span class="number">8</span>,<span class="number">5</span>), ST_Y((g.geo).geomout)::<span class="built_in">numeric</span>(<span class="number">8</span>,<span class="number">5</span>) )</span><br><span class="line"><span class="keyword">FROM</span> (<span class="keyword">SELECT</span> addid</span><br><span class="line">        <span class="keyword">FROM</span> addresses_to_geocode</span><br><span class="line">        <span class="keyword">WHERE</span> rating <span class="keyword">IS</span> <span class="literal">NULL</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> addid <span class="keyword">LIMIT</span> <span class="number">3</span>) <span class="keyword">AS</span> a</span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> addid, (geocode(address,<span class="number">1</span>)) <span class="keyword">AS</span> geo</span><br><span class="line">                <span class="keyword">FROM</span> addresses_to_geocode <span class="keyword">AS</span> ag</span><br><span class="line">                <span class="keyword">WHERE</span> ag.rating <span class="keyword">IS</span> <span class="literal">NULL</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> addid <span class="keyword">LIMIT</span> <span class="number">3</span>) <span class="keyword">AS</span> g <span class="keyword">ON</span> a.addid = g.addid</span><br><span class="line"><span class="keyword">WHERE</span> a.addid = addresses_to_geocode.addid;</span><br></pre></td></tr></table></figure>
<p>Since the geocoding process can be slow, it&#x2019;s suggested to process a small portion at a time. The address table was assigned an <code>addid</code> for each row as a index. The code always take <em>the first 3 rows not yet processed (rating column is null)</em> as the <em>sample</em> <code>a</code> to be geocoded.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> addid</span><br><span class="line">    <span class="keyword">FROM</span> addresses_to_geocode</span><br><span class="line">    <span class="keyword">WHERE</span> rating <span class="keyword">IS</span> <span class="literal">NULL</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> addid <span class="keyword">LIMIT</span> <span class="number">3</span>) <span class="keyword">AS</span> a</span><br></pre></td></tr></table></figure>
<p><img src="table1.png" alt="table 1"><br>The <em>result of geocoding</em> <code>g</code> is joined with the <code>addid</code> of the <em>sample</em> <code>a</code>.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">LEFT JOIN (<span class="keyword">SELECT</span> addid, (geocode(address,<span class="number">1</span>)) <span class="keyword">AS</span> geo</span><br><span class="line">            <span class="keyword">FROM</span> addresses_to_geocode <span class="keyword">AS</span> ag</span><br><span class="line">            <span class="keyword">WHERE</span> ag.rating <span class="keyword">IS</span> <span class="literal">NULL</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> addid <span class="keyword">LIMIT</span> <span class="number">3</span></span><br><span class="line">          ) <span class="keyword">AS</span> g <span class="keyword">ON</span> a.addid = g.addid</span><br></pre></td></tr></table></figure>
<p><img src="table2.png" alt="table 2"></p>
<p>Then the <code>address table</code> was joined with <em>that joined table a-g</em> by <code>addid</code> and corresponding columns were updated. </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> addresses_to_geocode</span><br><span class="line">  <span class="keyword">SET</span> ( rating, new_address, lon, lat)</span><br><span class="line">    = ( <span class="keyword">COALESCE</span>((g.geo).rating,<span class="number">-1</span>), pprint_addy((g.geo).addy),</span><br><span class="line">       ST_X((g.geo).geomout)::<span class="built_in">numeric</span>(<span class="number">8</span>,<span class="number">5</span>), ST_Y((g.geo).geomout)::<span class="built_in">numeric</span>(<span class="number">8</span>,<span class="number">5</span>) )</span><br><span class="line"><span class="keyword">FROM</span> </span><br><span class="line">...</span><br><span class="line"><span class="keyword">WHERE</span> a.addid = addresses_to_geocode.addid;</span><br></pre></td></tr></table></figure>
<p>The initial value of rating column is <code>NULL</code>. Valid geocoding match have a rating number range from 0 to around 100. Some input don&#x2019;t have valid <code>geocode</code> function return value, which make the rating column to be <code>NULL</code>. Then it was replaced with <code>-1</code> by the <code>COALESCE</code> function to be separated with the unprocessed rows, so that the next run can skip them. </p>
<p>The join of <code>a</code> and <code>g</code> may seem redundant at first since <code>g</code> already included the <code>addid</code> column. However when some rows has no match and no value is returned by <code>geocode</code> function, <code>g</code> will only have rows with return values.<br><img src="table3.png" alt="table 3"><br>Joining <code>g</code> with address table will only update these rows by <code>addid</code>. <code>COALESCE</code> function will not take any effect since the empty row <code>addid</code> were not even included. Then the next run will select them again because they still satisfied the sample selection condition, which will mess up the control logic.</p>
<p>Instead joining <code>a</code> and <code>g</code> will have all <code>addid</code> in sample, and the no match rows have <code>NULL</code> in rating column.<br><img src="table4.png" alt="table 4"><br>The next joining with address table will have the rating column updated correctly by <code>COALESCE</code> function.<br><img src="table5.png" alt="table 5"></p>
<p>This programming pattern is new for me. I think it&#x2019;s because SQL don&#x2019;t have the fine grade control of the regular procedure languages, but we still need more control some times so we have this.</p>
<h2 id="problem-with-ill-formated-address"><a href="#Problem-With-Ill-Formated-Address" class="headerlink" title="Problem With Ill Formated Address"></a>Problem With Ill Formated Address</h2><p>In my experiment with test data I found the example code above often had serious performance problems. It was very similar to another problem I observed: if I run this line with different table sizes, it should have similar performance since it is supposed to only process the first 3 rows.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> geocode(address_string,<span class="number">1</span>) </span><br><span class="line">    <span class="keyword">FROM</span> address_sample <span class="keyword">LIMIT</span> <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>Actually it took much, much longer on a larger table. It seemed that it was geocoding the whole table first, then only return the first 3 rows. If I subset the table more explicitly this problem disappeared:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> geocode(sample.address_string, <span class="number">1</span>) </span><br><span class="line">    <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> address_string </span><br><span class="line">            <span class="keyword">FROM</span> address_sample <span class="keyword">LIMIT</span> <span class="number">3</span></span><br><span class="line">         ) <span class="keyword">as</span> <span class="keyword">sample</span>;</span><br></pre></td></tr></table></figure>
<p>I modified the example code similarly. Instead of using <code>LIMIT</code> directly in the <code>WHERE</code> clause, </p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> addid, (geocode(address,<span class="number">1</span>)) <span class="keyword">AS</span> geo</span><br><span class="line">    <span class="keyword">FROM</span> addresses_to_geocode <span class="keyword">AS</span> ag</span><br><span class="line">    <span class="keyword">WHERE</span> ag.rating <span class="keyword">IS</span> <span class="literal">NULL</span> <span class="keyword">ORDER</span> <span class="keyword">BY</span> addid <span class="keyword">LIMIT</span> <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>I explicitly select the sample rows then put it in the <code>FROM</code> clause, problem solved.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> sample.addid, geocode(sample.input_address,<span class="number">1</span>) <span class="keyword">AS</span> geo</span><br><span class="line">    <span class="keyword">FROM</span> (<span class="keyword">SELECT</span> addid, input_address</span><br><span class="line">            <span class="keyword">FROM</span> address_table <span class="keyword">WHERE</span> rating <span class="keyword">IS</span> <span class="literal">NULL</span></span><br><span class="line">            <span class="keyword">ORDER</span> <span class="keyword">BY</span> addid <span class="keyword">LIMIT</span> sample_size</span><br><span class="line">         ) <span class="keyword">AS</span> <span class="keyword">sample</span></span><br></pre></td></tr></table></figure>
<p>Later I found this problem only occurs when the first row of table have invalid address for which the geocode function have no return value. These are the <code>explain analysis</code> results from pgAdmin SQL query tool:</p>
<p>The example code runs on 100 row table on first time, with first row address invalid. The first step of <code>Seq Scan</code> take 284 s (this was on my home pc server running on regular hard drive with all states data, so the performance was bad) to return 99 rows of geocoding result(one row has no match).</p>
<p><img src="1_explain_scan_v1.png" alt="1. example code returned 99 rows in seq scan "></p>
<p><img src="2_explain_limit_v1.png" alt="2. example code limited results to 3 rows later"></p>
<p>While my modified version only processed 3 rows in first step.<br><img src="3_explain_scan_v2.png" alt="3. modified version geocoded 3 rows only"></p>
<p>After the first row has been processed and marked with <code>-1</code> in rating, the example code no longer have the problem<br><img src="4_explain_scan_v1_2nd_run.png" alt="4. example code no longer have problem with valid inputs"></p>
<p>If I move the problematic row to the second row, there was no problem either. It seemed that the postgresql planner had some trouble only when the first row didn&#x2019;t have valid return value. The <code>geocode</code> function authors didn&#x2019;t find this bug probably because this is a special case, but it&#x2019;s very common in my data. Because I sorted the addresses by zipcode, many ill formated addresses with invalid zipcode always appear in the beginning of the file.</p>
<h2 id="making-a-full-script"><a href="#Making-A-full-Script" class="headerlink" title="Making A full Script"></a>Making A full Script</h2><p>To have a better control of the whole process, I need some <a href="http://www.postgresql.org/docs/current/static/plpgsql-control-structures.html" target="_blank" rel="external">control structures</a> from PL/pgSQL - sql procedural Language.</p>
<p>First I make the geocoding code as a <code>geocode_sample</code> function with the sample size for each run as parameter.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> geocode_sample(sample_size <span class="built_in">integer</span>) </span><br><span class="line">    <span class="keyword">RETURNS</span> <span class="built_in">void</span> <span class="keyword">AS</span> $$</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ LANGUAGE plpgsql;</span><br></pre></td></tr></table></figure>
<p><code>Create or replace</code> make debugging and making changes easier because new version will replace existing version.</p>
<p>Then this main control function <code>geocode_table</code> will calculate the number of rows for whole table, decide how many sample runs it needed to update the whole table, then run the <code>geocode_sample</code> function in a loop with that number. I don&#x2019;t want to use a conditional loop because if there is something wrong, the code could stuck at some point and have a endless loop. I&#x2019;d rather just run the code with calculated times then check the table to make sure all rows are processed correctly.</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> geocode_table();</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> geocode_table(</span><br><span class="line">    <span class="keyword">OUT</span> table_size <span class="built_in">integer</span>,</span><br><span class="line">    <span class="keyword">OUT</span> remaining_rows <span class="built_in">integer</span>) <span class="keyword">AS</span> $func$</span><br><span class="line"><span class="keyword">DECLARE</span> sample_size <span class="built_in">integer</span>;</span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">    <span class="keyword">SELECT</span> reltuples::<span class="built_in">bigint</span> <span class="keyword">INTO</span> table_size</span><br><span class="line">                    <span class="keyword">FROM</span>  pg_class</span><br><span class="line">                    <span class="keyword">WHERE</span> <span class="keyword">oid</span> = <span class="string">&apos;public.address_table&apos;</span>::regclass;</span><br><span class="line">    sample_size := 1;</span><br><span class="line">    FOR i IN 1..(<span class="keyword">SELECT</span> table_size / sample_size + <span class="number">1</span>) <span class="keyword">LOOP</span></span><br><span class="line">        PERFORM geocode_sample(sample_size);</span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">LOOP</span>;</span><br><span class="line">    <span class="keyword">SELECT</span> <span class="keyword">count</span>(*) <span class="keyword">INTO</span> remaining_rows </span><br><span class="line">        <span class="keyword">FROM</span> address_table <span class="keyword">WHERE</span> rating <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">$func$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br></pre></td></tr></table></figure>
<ol>
<li>I used <code>drop function if exists</code> here because the <code>Create or replace</code> doesn&#x2019;t work if the function return type was changed.</li>
<li>It&#x2019;s widely acknowledged that calculating row count for a table by <code>count(*)</code> is not optimal. The method I used should be much quicker if the table statistics is up to date. I used to put a line of <code>VACUUM ANALYZE</code> after the table was constructed and csv data was imported, but in every run it reported that no update was needed. It probably because the default postgresql settings made sure the information is up to date right for my case.</li>
<li>In the end I counted the rows not processed yet. The total row number and the remaining row number will be the return value of this function.</li>
</ol>
<p>The whole PL/pgSQL script is structured like this (<em>actual details inside functions are omitted to have a clear view of whole picture. See complete scripts and everything else in <a href="https://github.com/dracodoc/Geocode" target="_blank" rel="external">my github repo</a></em>):</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> address_table;</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> address_table(</span><br><span class="line">    row_seq <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    input_address <span class="built_in">varchar</span>(<span class="number">255</span>),</span><br><span class="line">    zip <span class="built_in">varchar</span>(<span class="number">255</span>) </span><br><span class="line">);</span><br><span class="line"><span class="comment">-- aws version.</span></span><br><span class="line">COPY address_table FROM :input_file WITH DELIMITER &apos;|&apos; NULL &apos;NA&apos; CSV HEADER;</span><br><span class="line"><span class="comment">-- pc version.</span></span><br><span class="line"><span class="comment">-- COPY address_table FROM &apos;e:\\Data\\1.csv&apos; WITH DELIMITER &apos;,&apos; NULL &apos;NA&apos; CSV HEADER;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> address_table</span><br><span class="line">    <span class="keyword">ADD</span> addid <span class="built_in">serial</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> PRIMARY <span class="keyword">KEY</span>,</span><br><span class="line">    <span class="keyword">ADD</span> rating <span class="built_in">integer</span>, </span><br><span class="line">    <span class="keyword">ADD</span> lon <span class="built_in">numeric</span>,</span><br><span class="line">    <span class="keyword">ADD</span> lat <span class="built_in">numeric</span>,</span><br><span class="line">    <span class="keyword">ADD</span> output_address <span class="built_in">text</span>,</span><br><span class="line">    <span class="keyword">ADD</span> geomout geometry,  <span class="comment">-- a point geometry in NAD 83 long lat.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--&lt;&lt; geocode function --</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> geocode_sample(sample_size <span class="built_in">integer</span>) </span><br><span class="line">    <span class="keyword">RETURNS</span> <span class="built_in">void</span> <span class="keyword">AS</span> $$</span><br><span class="line">...</span><br><span class="line"><span class="keyword">END</span>;</span><br><span class="line">$$ LANGUAGE plpgsql;</span><br><span class="line"><span class="comment">-- geocode function &gt;&gt;--</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--&lt;&lt; main control --</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">FUNCTION</span> <span class="keyword">IF</span> <span class="keyword">EXISTS</span> geocode_table();</span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">OR</span> <span class="keyword">REPLACE</span> <span class="keyword">FUNCTION</span> geocode_table(</span><br><span class="line">    <span class="keyword">OUT</span> table_size <span class="built_in">integer</span>,</span><br><span class="line">    <span class="keyword">OUT</span> remaining_rows <span class="built_in">integer</span>) <span class="keyword">AS</span> $func$</span><br><span class="line">...</span><br><span class="line"><span class="keyword">END</span></span><br><span class="line">$func$ <span class="keyword">LANGUAGE</span> plpgsql;</span><br><span class="line"><span class="comment">-- main control &gt;&gt;--</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> geocode_table();</span><br></pre></td></tr></table></figure>
<ol>
<li>First I dropped the address table if previously exists, created the table with columns in characters type because I don&#x2019;t want the leading zero in zipcode lost in converting to integer.</li>
<li>I have two version of importing csv into table, one for testing in windows pc, another one for AWS linux instance. The SQL <code>copy</code> command need the postgresql server user to have permission for the input file, so you need to make sure the folder permission is correct. The linux version used a parameter for input file path.</li>
<li>Then the necessary columns were added to table and the index was built.</li>
<li>The last line run the main control function and print the return value of it in the end, which is the total row number and remaining row number of input table.</li>
</ol>
<h2 id="intersection-address"><a href="#Intersection-address" class="headerlink" title="Intersection address"></a>Intersection address</h2><p>Another type of input is intersections. Tiger Geocoder have a function <a href="http://postgis.net/docs/Geocode_Intersection.html" target="_blank" rel="external"><code>Geocode_Intersection</code></a> work like this:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> pprint_addy(addy), st_astext(geomout), rating</span><br><span class="line">    <span class="keyword">FROM</span> geocode_intersection( <span class="string">&apos;Haverford St&apos;</span>,<span class="string">&apos;Germania St&apos;</span>, <span class="string">&apos;MA&apos;</span>, <span class="string">&apos;Boston&apos;</span>, <span class="string">&apos;02130&apos;</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>It take two street names, state, city and zipcode then output multiple location candidates with ratings. The script of geocoding street addresses only need some minor changes on input table column format and function parameters to work on intersections. I&#x2019;ll just post the finished whole script for reference after all discussions.</p>
<h2 id="map-to-census-block"><a href="#Map-to-Census-Block" class="headerlink" title="Map to Census Block"></a>Map to Census Block</h2><p>One important goal of my project is to map addresses to census block, then we can link the NFIRS data with other public data and produce much more powerful analysis, especially the <a href="http://www.census.gov/programs-surveys/ahs.html" target="_blank" rel="external">American Housing Survey(AHS)</a> and the <a href="https://www.census.gov/programs-surveys/acs/" target="_blank" rel="external">American Community Survey(ACS)</a>.</p>
<p>There is a <a href="http://postgis.net/docs/Get_Tract.html" target="_blank" rel="external"><code>Get_Tract</code> function</a> in Tiger Geocoder which return the <em>census tract</em> id for a location. For <em>census block</em> mapping people seemed to be just using <a href="http://postgis.org/docs/ST_Contains.html" target="_blank" rel="external">ST_Contains</a> like <a href="http://gis.stackexchange.com/questions/137870/finding-census-block-for-given-address-using-tiger-geocoder" target="_blank" rel="external">this answer</a> in stackexchange:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> tabblock_id <span class="keyword">AS</span> <span class="keyword">Block</span>,</span><br><span class="line">    <span class="keyword">substring</span>(tabblock_id <span class="keyword">FROM</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="number">11</span>) <span class="keyword">AS</span> Blockgroup,</span><br><span class="line">    <span class="keyword">substring</span>(tabblock_id <span class="keyword">FROM</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="number">9</span>) <span class="keyword">AS</span> Tract,</span><br><span class="line">    <span class="keyword">substring</span>(tabblock_id <span class="keyword">FROM</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="number">5</span>) <span class="keyword">AS</span> County,</span><br><span class="line">    <span class="keyword">substring</span>(tabblock_id <span class="keyword">FROM</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="number">2</span>) <span class="keyword">AS</span> STATE</span><br><span class="line"><span class="keyword">FROM</span> tabblock</span><br><span class="line"><span class="keyword">WHERE</span> ST_Contains(the_geom, ST_SetSRID(ST_Point(<span class="number">-71.101375</span>, <span class="number">42.31376</span>), <span class="number">4269</span>))</span><br></pre></td></tr></table></figure>
<p>The national data loaded by Tiger Geocoder have a table <code>tabblock</code> which have the information of census blocks. <code>ST_Contains</code> will test the spatial relationship between two geometries, in our case it will be whether polygon or multi polygon of census block contains the point of interest. The <code>Where</code> clause select the only record that satisfy this condition for the point.</p>
<p>The census block id is a 15 digits code constructed from state and county fips code, census tract id, blockgroup id and the census block number. The code example above actually are not ideal for me since it included all the prefix in each column. My code will work on the results from the geocoding script above:</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> address_table</span><br><span class="line">    <span class="keyword">SET</span> (tabblock_id, STATE, county, tractid)</span><br><span class="line">      = (<span class="keyword">COALESCE</span>(ab.tabblock_id,<span class="string">&apos;FFFF&apos;</span>),</span><br><span class="line">         <span class="keyword">substring</span>(ab.tabblock_id <span class="keyword">FROM</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="number">2</span>),</span><br><span class="line">         <span class="keyword">substring</span>(ab.tabblock_id <span class="keyword">FROM</span> <span class="number">3</span> <span class="keyword">FOR</span> <span class="number">3</span>),</span><br><span class="line">         <span class="keyword">substring</span>(ab.tabblock_id <span class="keyword">FROM</span> <span class="number">1</span> <span class="keyword">FOR</span> <span class="number">11</span>)</span><br><span class="line">        )</span><br><span class="line"><span class="keyword">FROM</span></span><br><span class="line">    (<span class="keyword">SELECT</span> addid</span><br><span class="line">        <span class="keyword">FROM</span> address_table</span><br><span class="line">        <span class="keyword">WHERE</span> (geomout <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>) <span class="keyword">AND</span> (tabblock_id <span class="keyword">IS</span> <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">ORDER</span> <span class="keyword">BY</span> addid <span class="keyword">LIMIT</span> block_sample_size) <span class="keyword">AS</span> a</span><br><span class="line">    <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> (<span class="keyword">SELECT</span> a.addid, b.tabblock_id</span><br><span class="line">                <span class="keyword">FROM</span> address_table <span class="keyword">AS</span> a, tabblock <span class="keyword">AS</span> b</span><br><span class="line">                <span class="keyword">WHERE</span> (geomout <span class="keyword">IS</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>) <span class="keyword">AND</span> (a.tabblock_id <span class="keyword">IS</span> <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">AND</span> ST_Contains(b.the_geom, ST_SetSRID(ST_Point(a.lon, a.lat), <span class="number">4269</span>))</span><br><span class="line">                <span class="keyword">ORDER</span> <span class="keyword">BY</span> addid <span class="keyword">LIMIT</span> block_sample_size) <span class="keyword">AS</span> ab <span class="keyword">ON</span> a.addid = ab.addid</span><br><span class="line"><span class="keyword">WHERE</span> a.addid = address_table.addid;</span><br></pre></td></tr></table></figure>
<ul>
<li>I didn&#x2019;t include the state fips as prefix in county fips since strictly speaking county fips is 3 digits, although you always need to use it with state fips together. I included the census tract because some location may have ambiguity but the census tract most likely will be same.</li>
<li>This code is based on same principle of the geocoding code with a little bit change:<ul>
<li>It need to work on top of geocoding results, so the sample for each run are the rows that have been geocoded (thus geomout column is not <code>NULL</code>), but not yet mapped to census block (<code>tabblock_id</code> is <code>NULL</code>), and sorted by <code>addid</code>, limited by sample size.</li>
<li>Similar to geocode code, I need to join the sample <code>addid</code> with lookup result to make sure even the rows without return value are included in result. Then the <code>NULL</code> rating value of those rows will be replaced with an special value to mark the row as processed already but without match. This step is critical for the updating process to work properly.</li>
</ul>
</li>
</ul>
<p>In theory this mapping is much easier than geocoding since there is not much ambiguity. And every address should belong to some census block. Actually I found <a href="http://gis.stackexchange.com/questions/170217/find-census-block-for-street-intersection-with-tiger-geocoder" target="_blank" rel="external">many street intersections don&#x2019;t have matches</a>. I tested the same address in <a href="http://geocoding.geo.census.gov/geocoder/" target="_blank" rel="external">the offcial Census website</a> and it find the match! </p>
<p>Here is the example data I used, the <code>geocode_intersection</code> function returned a street address and coordinates from two streets:</p>
<pre><code>row_seq        | 2716
street_1       |  FLORIDA AVE NW
street_2       | MASSACHUSETTS AVE NW
state          | DC
city           | WASHINGTON
zip            | 20008
addid          | 21
rating         | 3
lon            | -77.04879
lat            | 38.91150
output_address | 2198 Florida Ave NW, Washington, DC 20008
</code></pre><p>I used different test methods and found interesting results:</p>
<table>
<thead>
<tr>
<th style="text-align:left">input</th>
<th style="text-align:left">method</th>
<th style="text-align:left">result</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">2 streets</td>
<td style="text-align:left">geocode_intersection</td>
<td style="text-align:left">(-77.04879, 38.91150)</td>
</tr>
<tr>
<td style="text-align:left">geocode_intersection output address</td>
<td style="text-align:left">geocode</td>
<td style="text-align:left">(-77.04871, 38.91144)</td>
</tr>
<tr>
<td style="text-align:left">geocode_intersection output address</td>
<td style="text-align:left">Census website</td>
<td style="text-align:left">(-77.048775,38.91151) GEOID: 110010055001010</td>
</tr>
<tr>
<td style="text-align:left">geocode_intersection coordinates, 5 digits</td>
<td style="text-align:left">Census website</td>
<td style="text-align:left">census block GEOID: 110010041003022</td>
</tr>
<tr>
<td style="text-align:left">geocode_intersection coordinates, 5 digits</td>
<td style="text-align:left">Tiger Geocoder</td>
<td style="text-align:left">census block GEOID: 110010041003022</td>
</tr>
<tr>
<td style="text-align:left">geocode_intersection coordinates, 6 digits</td>
<td style="text-align:left">Tiger Geocoder</td>
<td style="text-align:left">census block: no match</td>
</tr>
</tbody>
</table>
<ul>
<li>If I feed the street address output from <code>geocode_intersection</code> back to <code>geocode</code> function, the coordinates output will have slight difference with the coordinates output from <code>geocode_intersection</code>. My theory is that <code>geocode_intersection</code> function first calculate the intersection point from the geometry information of two streets, then reverse geocode that coordinates into street address. The street number is usually interpolated so if you geocode that street address back to coordinates there could be difference. <strong>Update</strong>: <a href="http://gis.stackexchange.com/a/115666" target="_blank" rel="external">Some interesting background information about the street address locations and ranges</a>.</li>
<li>The slight difference may result in different census block output, probably because these locations are on street intersections which are more than likely to be boundary of census blocks.</li>
<li>Using the geometry or the coordinates output (6 digits after dot) from <code>geocode_intersection</code> for <code>ST_Contains</code> could have empty result, i.e. no census block have contain relationship of these points. I&#x2019;m not sure the reason of this, only observed that using coordinates with 5 digits after dot will find a match in most time. This is an open question need to consulting with the experts on this.</li>
</ul>
<h2 id="work-in-batch"><a href="#Work-In-Batch" class="headerlink" title="Work In Batch"></a>Work In Batch</h2><p>I was planning to geocode addresses by states to improve the performance, so I&#x2019;ll need to process lots of files. After some experimentations, I developed a batch workflow:</p>
<ol>
<li><p>The script discussed above can take a csv input, geocode addresses, map census block, update the table. I used this psql command line to execute the script. Note I have a .pgpass file in my user folder so I don&#x2019;t need to write database password in the command line, and I saved a copy of the console messages to log file. </p>
<pre><code>psql -d census -U postgres -h localhost -w -v input_file=&quot;&apos;/home/ubuntu/geocode/address_input/address_sample.csv&apos;&quot; -f geocode_batch.sql 2&gt;&amp;1 | tee address.log
</code></pre></li>
<li><p>I need to save the result table to csv. The <code>Copy</code> in SQL require the postgresql user to have permission for output file, so I used the psql meta command <code>\Copy</code> instead. It can be written inside the PL/pgSQL script but I cannot make it to use parameter as output file name. So I have to write another psql command line:</p>
<pre><code>psql -d census -U postgres -h localhost -w -c &apos;\copy address_table to /home/ubuntu/geocode/address_output/1.csv csv header&apos;
</code></pre></li>
<li><p>The above two lines will take care of one input file. If I put all input files into one folder, I can generate a shell script to process each input file with above command line. At first I tried to use shell script directly to read file names and loop with them, but it became very cumbersome and error prone because I want to generate <em>output file</em> name dynamically from <em>input file</em> names then transfer them as psql command line parameters. I ended up with a simple python script to generate the shell script I wanted. </p>
<p> Before running the shell script I need to change the permission:</p>
<pre><code>chmod +x ./batch.sh
sh ./batch.sh  
</code></pre></li>
</ol>
<h2 id="exception-handling-and-progress-report"><a href="#Exception-Handling-And-Progress-Report" class="headerlink" title="Exception Handling And Progress Report"></a>Exception Handling And Progress Report</h2><p>The NFIRS data have many ill formated addresses that could cause problem for <code>geocode</code> function. I decided that it&#x2019;s better to process one year&#x2019;s data first, then collect all the problem cases and design a cleaning procedure before processing other years&#x2019; data. </p>
<p>This means the workflow should be able to skip on errors and mark the problems. The script above can handle the cases when there is no match returned from the <code>geocode</code> function, but any exception occurred in runtime will interrupt the script. Since the <code>geocode_sample</code> is called in a loop inside the main control function, the whole script is one single transaction. Once the transaction is interrupted, it will be rolled back and all the previous geocoding results are lost. See <a href="http://www.postgresql.org/docs/current/static/plpgsql-structure.html" target="_blank" rel="external">more about this</a>. </p>
<p>However, <a href="http://www.postgresql.org/docs/current/static/plpgsql-control-structures.html#PLPGSQL-ERROR-TRAPPING" target="_blank" rel="external">adding an EXCEPTION clause</a> effectively forms a subtransaction that can be rolled back without affecting the outer transaction.</p>
<p>Therefore I added this exception handling part in the <code>geocode_sample</code> function:</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">CREATE OR REPLACE FUNCTION geocode_sample(sample_size integer) </span><br><span class="line">    RETURNS void AS $$</span><br><span class="line">DECLARE OUTPUT address_table%ROWTYPE;    </span><br><span class="line">BEGIN</span><br><span class="line">...</span><br><span class="line">EXCEPTION</span><br><span class="line">WHEN OTHERS THEN</span><br><span class="line">    SELECT * INTO OUTPUT </span><br><span class="line">        FROM address_table </span><br><span class="line">        WHERE rating IS NULL ORDER BY addid LIMIT 1;</span><br><span class="line">    RAISE NOTICE &apos;&lt;address error&gt; in samples started from: %&apos;, OUTPUT;</span><br><span class="line">    RAISE notice &apos;-- !!! % % !!!--&apos;, SQLERRM, SQLSTATE;</span><br><span class="line">    UPDATE address_table</span><br><span class="line">        SET rating = -2</span><br><span class="line">    FROM (SELECT addid</span><br><span class="line">            FROM address_table </span><br><span class="line">            WHERE rating IS NULL ORDER BY addid LIMIT sample_size</span><br><span class="line">         ) AS sample</span><br><span class="line">    WHERE sample.addid = address_table.addid;</span><br><span class="line">END;</span><br><span class="line">$$ LANGUAGE plpgsql;</span><br></pre></td></tr></table></figure>
<p>This code will catch any exception, print the first row of current sample to notify the location of error, also print the original exception message. </p>
<pre><code>psql:geocode_batch.sql:179: NOTICE:  &lt;address error&gt; in samples started from: (1501652,&quot; RIVER (AT BLOUNT CO) (140 , KNOXVILLE, TN 37922&quot;,37922,27556,,,,,,,,,)
CONTEXT:  SQL statement &quot;SELECT geocode_sample(sample_size)&quot;
PL/pgSQL function geocode_table() line 24 at PERFORM
psql:geocode_batch.sql:179: NOTICE:  -- !!! invalid regular expression: parentheses () not balanced 2201B !!!--
</code></pre><p>To make sure the script will continue work on the remaining rows, it also set the rating column of the current sample to be <code>-2</code>, thus they will be skipped in latter runs. </p>
<p>One catch of this method is the whole sample will be skipped even only one row in it caused problem, then I may need to check them again after one pass. However I didn&#x2019;t find a better way to find the row caused the exception other than set up some marker for every row and keep updating it. Instead, I tested the performance with different sample size, i.e. how many rows will the <code>geocode_sample</code> function process in one run. It turned out sample size 1 didn&#x2019;t have obvious performance penalty, maybe because the extra cost of small sample is negligible compared to the geocoding function cost. With a sample size 1 the exception handling code will always mark the problematic row only, and the code is much simpler.</p>
<p>Another important feature I want is progress report. If I split the NFIRS data by state, one state data often has tens of thousands of rows and take several hours to finish. I don&#x2019;t want to find error or problem until it finishes. So I added some progress report like this:</p>
<pre><code>psql:geocode_batch.sql:178: NOTICE:  &gt; 2015-11-18 20:26:51+00 : Start on table of 10845
psql:geocode_batch.sql:178: NOTICE:  &gt; time passed | address processed &lt;&lt;&lt;&lt; address left
psql:geocode_batch.sql:178: NOTICE:  &gt; 00:00:54.3  |    100 &lt;&lt;&lt;&lt;    10745
psql:geocode_batch.sql:178: NOTICE:  &gt; 00:00:21.7  |    200 &lt;&lt;&lt;&lt;    10645
</code></pre><p>First it report the size of whole table, then the time taken for every 100 rows processed, and how many rows are left. It&#x2019;s pretty obvious in above example that the first 100 rows take more time. It&#x2019;s because many address with ill formated zipcode were sorted on top.</p>
<p>Similarly, the mapping of census block have a progress report:</p>
<pre><code>psql:geocode_batch.sql:178: NOTICE:  ==== start mapping census block ====
psql:geocode_batch.sql:178: NOTICE:  # time passed | address to block &lt;&lt;&lt;&lt; address left
psql:geocode_batch.sql:178: NOTICE:  # 00:00:02.6  |    1000    &lt;&lt;&lt;&lt;    9845
psql:geocode_batch.sql:178: NOTICE:  # 00:00:03.4  |    2000    &lt;&lt;&lt;&lt;    8845
</code></pre><h2 id="summary-and-open-questions"><a href="#Summary-And-Open-Questions" class="headerlink" title="Summary And Open Questions"></a>Summary And Open Questions</h2><p><strong>I put everything in <a href="https://github.com/dracodoc/Geocode" target="_blank" rel="external">this Github repository</a></strong>. </p>
<p>My script has processed almost one year&#x2019;s data, but I&#x2019;m not really satisfied with the performance yet. When I tested the 44185 MD, DC addresses in the AWS free tier server with MD, DC database, the average time per row is about 60 ms, while the full server with all states have the average time of 342 ms. Some other states with more ill formated addresses have worse performance. </p>
<p>I have updated the Tiger database index and tuned the postgresql configurations. I can try parallel but the cpu should not be the bottle neck here, and <a href="http://geeohspatial.blogspot.com/2013/12/a-simple-function-for-parallel-queries_18.html" target="_blank" rel="external">the hack I found to enable postgresql run parallel</a> is not easily manageable. Somebody also mentioned partitioning database, but I&#x2019;m not sure if this will help.</p>
<p>And here are some open questions I will ask in PostGIS community, some of them may have the potential to further improve performance:</p>
<ol>
<li><p>Why is a server with 2 states data much faster than the server with all states data? I assume it&#x2019;s because the bad address that don&#x2019;t have a exact hit at first will cost much more time when the geocoder checked all states. With only 2 states this search is limited and stopped much early. This can be further verified by comparing the performance of two test cases in each server, one with exact match perfect address, another one with lots of invalid addresses.</p>
<p> There is a <code>restrict_region</code> parameter in <code>geocode</code> function looks promising if it can limit the search range, since I have enough information or reason to believe the state information is correct. I wrote a query trying to use one state&#x2019;s geometry as the limiting parameter:</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> geocode(<span class="string">&apos;501 Fairmount DR , Annapolis, MD 20137&apos;</span>, <span class="number">1</span>, the_geom) </span><br><span class="line">    <span class="keyword">FROM</span> tiger.state <span class="keyword">WHERE</span> statefp = <span class="string">&apos;24&apos;</span>;</span><br></pre></td></tr></table></figure>
<p> and compared the performance with the simple version</p>
 <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> geocode(<span class="string">&apos;501 Fairmount DR , Annapolis, MD 20137&apos;</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p> I didn&#x2019;t find performance gain with the parameter. Instead it lost the performance gain from caching, which usually came from running same query immediately again because all the needed data have been cached in RAM. </p>
<p> Maybe my usage is not proper, or this parameter is not intended to work as I expected. However if the search range can be limited, the performance gain could be substantial.</p>
</li>
<li><p>Will normalizing address first improve the performance? I don&#x2019;t think it will help unless I can filter bad address and remove them from input totally, which may not be the case for my usage of NFIRS data. The new PostGIS 2.2.0 looks promising but the ansible playbook is not updated yet, and I haven&#x2019;t have the chance to setup the server again by myself.</p>
<p> One possible improvement to my workflow is to try to separate bad formatted addresses with the good ones. I already separated some of them by sorting by zipcode, but there are some addresses with a valid zipcode are obviously incomplete. The most important reason of separate all input by state is to have the server cache all the data needed in RAM. If the server meet some bad formatted addresses in the middle of table and started to look up all states, the already loaded whole state cache could be messed up. Then the good addresses need the geocoder to read state data from hard drive again. If the cache update statistics could be summarized from the server log, this theory can be verified.</p>
<p> I&#x2019;ve almost finished one year&#x2019;s data. After it finished I&#x2019;ll design more clean up procedures, and maybe move all suspicious addresses out to make sure the better shaped addresses geocoding are not interrupted.</p>
</li>
<li><p>Will replacing the default normalizing function with the <a href="http://postgis.net/docs/Address_Standardizer.html" target="_blank" rel="external">Address Standardizer</a> help? I didn&#x2019;t find the normalizing step too time consuming in my experiments. However if it can produce better formated address from bad input, that could help the geocoding process.</p>
</li>
<li>Why 6 digits coordinates of street intersections output often don&#x2019;t have matched census block, but coordinates round up to 5 digits have match in most of time?</li>
</ol>
<h2 id="version-history"><a href="#Version-History" class="headerlink" title="Version History"></a>Version History</h2><ul>
<li>2015-11-19 : First version.</li>
<li>2016-05-11 : Added Summary.</li>
<li>2016-08-19 : Syntax highlighting.</li>
</ul>

      
    </div>

    <div>
      
        

      
    </div>

    <div>
      
        

      
    </div>

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/DataKind/" rel="tag">#DataKind</a>
          
            <a href="/tags/NFIRS/" rel="tag">#NFIRS</a>
          
            <a href="/tags/Geocoding/" rel="tag">#Geocoding</a>
          
            <a href="/tags/Tiger-Geocoder/" rel="tag">#Tiger Geocoder</a>
          
            <a href="/tags/PostGIS/" rel="tag">#PostGIS</a>
          
            <a href="/tags/postgresql/" rel="tag">#postgresql</a>
          
        </div>
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2015/11/17/Geocoding/" rel="next" title="Geocoding 18 million addresses with PostGIS Tiger Geocoder">
                <i class="fa fa-chevron-left"></i> Geocoding 18 million addresses with PostGIS Tiger Geocoder
              </a>
            
          </div>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/01/31/data-cleaning/" rel="prev" title="Data Cleaning Part 1 - NYC Taxi Trip Data, Looking For Stories Behind Errors">
                Data Cleaning Part 1 - NYC Taxi Trip Data, Looking For Stories Behind Errors <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          
  <div class="comments" id="comments">
    
      <div id="disqus_thread">
        <noscript>
          Please enable JavaScript to view the
          <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a>
        </noscript>
      </div>
    
  </div>


        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            Overview
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel ">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="dracodoc" />
          <p class="site-author-name" itemprop="name">dracodoc</p>
          <p class="site-description motion-element" itemprop="description">This is about my exploration of Data Science, came from research background of AI, artificial learning and evolution.</p>
        </div>
        <nav class="site-state motion-element">
          <div class="site-state-item site-state-posts">
            <a href="/archives">
              <span class="site-state-item-count">9</span>
              <span class="site-state-item-name">posts</span>
            </a>
          </div>

          
            <div class="site-state-item site-state-categories">
              <a href="/categories">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">categories</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-tags">
              <a href="/tags">
                <span class="site-state-item-count">20</span>
                <span class="site-state-item-name">tags</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        
          <div class="links-of-blogroll motion-element links-of-blogroll-inline">
            <div class="links-of-blogroll-title">
              <i class="fa  fa-fw fa-globe"></i>
              Links
            </div>
            <ul class="links-of-blogroll-list">
              
                <li class="links-of-blogroll-item">
                  <a href="http://www.R-bloggers.com" title="R-bloggers" target="_blank">R-bloggers</a>
                </li>
              
            </ul>
          </div>
        

      </section>

      
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">
            
              
            
            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#summary"><span class="nav-number">1.</span> <span class="nav-text">Summary</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#introduction"><span class="nav-number">2.</span> <span class="nav-text">Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#tiger-geocoder-geocode-function"><span class="nav-number">3.</span> <span class="nav-text">Tiger Geocoder Geocode Function</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#preparing-addresses"><span class="nav-number">4.</span> <span class="nav-text">Preparing Addresses</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#test-geocoding-function"><span class="nav-number">5.</span> <span class="nav-text">Test Geocoding Function</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#problem-with-ill-formated-address"><span class="nav-number">6.</span> <span class="nav-text">Problem With Ill Formated Address</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#making-a-full-script"><span class="nav-number">7.</span> <span class="nav-text">Making A full Script</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#intersection-address"><span class="nav-number">8.</span> <span class="nav-text">Intersection address</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#map-to-census-block"><span class="nav-number">9.</span> <span class="nav-text">Map to Census Block</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#work-in-batch"><span class="nav-number">10.</span> <span class="nav-text">Work In Batch</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#exception-handling-and-progress-report"><span class="nav-number">11.</span> <span class="nav-text">Exception Handling And Progress Report</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#summary-and-open-questions"><span class="nav-number">12.</span> <span class="nav-text">Summary And Open Questions</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#version-history"><span class="nav-number">13.</span> <span class="nav-text">Version History</span></a></li></ol></div>
            
          </div>
        </section>
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy;  2015 - 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">dracodoc</span>
</div>

<div class="powered-by">
  Powered by <a class="theme-link" href="https://hexo.io">Hexo</a>
</div>

<div class="theme-info">
  Theme -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Mist
  </a>
</div>

        

        
      </div>
    </footer>

    <div class="back-to-top">
      <i class="fa fa-arrow-up"></i>
    </div>
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  



  
  <script type="text/javascript" src="/vendors/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/vendors/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/vendors/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/vendors/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.0.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.0.1"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.0.1"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.0.1"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.0.1"></script>



  



  

    <script type="text/javascript">
      var disqus_shortname = 'dracodocgithub';
      var disqus_identifier = '2015/11/19/Script-workflow/';
      var disqus_title = "Script And Workflow For Batch Geocoding Millions Of Address With PostGIS Tiger Geocoder";
      var disqus_url = 'http://dracodoc.github.io/2015/11/19/Script-workflow/';

      function run_disqus_script(disqus_script){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/' + disqus_script;
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      }

      run_disqus_script('count.js');
      
        run_disqus_script('embed.js');
      
    </script>
  




  
  
  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length == 0) {
       search_path = "search.xml";
    }
    var path = "/" + search_path;
    // monitor main search box;

    function proceedsearch() {
      $("body").append('<div class="popoverlay">').css('overflow', 'hidden');
      $('.popup').toggle();

    }
    // search function;
    var searchFunc = function(path, search_id, content_id) {
    'use strict';
    $.ajax({
        url: path,
        dataType: "xml",
        async: true,
        success: function( xmlResponse ) {
            // get the contents from search data
            isfetched = true;
            $('.popup').detach().appendTo('.header-inner');
            var datas = $( "entry", xmlResponse ).map(function() {
                return {
                    title: $( "title", this ).text(),
                    content: $("content",this).text(),
                    url: $( "url" , this).text()
                };
            }).get();
            var $input = document.getElementById(search_id);
            var $resultContent = document.getElementById(content_id);
            $input.addEventListener('input', function(){
                var matchcounts = 0;
                var str='<ul class=\"search-result-list\">';
                var keywords = this.value.trim().toLowerCase().split(/[\s\-]+/);
                $resultContent.innerHTML = "";
                if (this.value.trim().length > 1) {
                // perform local searching
                datas.forEach(function(data) {
                    var isMatch = true;
                    var content_index = [];
                    var data_title = data.title.trim().toLowerCase();
                    var data_content = data.content.trim().replace(/<[^>]+>/g,"").toLowerCase();
                    var data_url = data.url;
                    var index_title = -1;
                    var index_content = -1;
                    var first_occur = -1;
                    // only match artiles with not empty titles and contents
                    if(data_title != '' && data_content != '') {
                        keywords.forEach(function(keyword, i) {
                            index_title = data_title.indexOf(keyword);
                            index_content = data_content.indexOf(keyword);
                            if( index_title < 0 && index_content < 0 ){
                                isMatch = false;
                            } else {
                                if (index_content < 0) {
                                    index_content = 0;
                                }
                                if (i == 0) {
                                    first_occur = index_content;
                                }
                            }
                        });
                    }
                    // show search results
                    if (isMatch) {
                        matchcounts += 1;
                        str += "<li><a href='"+ data_url +"' class='search-result-title'>"+ data_title +"</a>";
                        var content = data.content.trim().replace(/<[^>]+>/g,"");
                        if (first_occur >= 0) {
                            // cut out 100 characters
                            var start = first_occur - 20;
                            var end = first_occur + 80;
                            if(start < 0){
                                start = 0;
                            }
                            if(start == 0){
                                end = 50;
                            }
                            if(end > content.length){
                                end = content.length;
                            }
                            var match_content = content.substring(start, end);
                            // highlight all keywords
                            keywords.forEach(function(keyword){
                                var regS = new RegExp(keyword, "gi");
                                match_content = match_content.replace(regS, "<b class=\"search-keyword\">"+keyword+"</b>");
                            });

                            str += "<p class=\"search-result\">" + match_content +"...</p>"
                        }
                        str += "</li>";
                    }
                })};
                str += "</ul>";
                if (matchcounts == 0) { str = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>' }
                if (keywords == "") { str = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>' }
                $resultContent.innerHTML = str;
            });
            proceedsearch();
        }
    });}

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched == false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };

    });

    $('.popup-btn-close').click(function(e){
      $('.popup').hide();
      $(".popoverlay").remove();
      $('body').css('overflow', '');
    });
    $('.popup').click(function(e){
      e.stopPropagation();
    });
  </script>


  

  

  

</body>
</html>
